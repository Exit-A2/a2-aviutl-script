@モールス
--track0:Xサイズ,0,100,30,1
--track1:画面高さ,0,3000,1080,1
--track2:時間,0,3,0,1
--dialog:色/col,color=0xffffff;赤線/chk,red=0;

local width = obj.track0
local height = obj.track1
local time = obj.track2

function rounded_rect(x, y, width, height, radius, color)
    obj.load("figure", "四角形", color, 100)
    obj.setoption("antialias", 0)
    obj.effect("リサイズ", "X", width - (radius * 2), "Y", height, "ドット数でサイズ指定", 1)
    obj.draw(x, y)
    obj.load("figure", "四角形", color, 100)
    obj.setoption("antialias", 0)
    obj.effect("リサイズ", "X", width, "Y", height - (radius * 2), "ドット数でサイズ指定", 1)
    obj.draw(x, y)
    obj.load("figure", "円", color, radius * 2)
    obj.setoption("antialias", 0)
    obj.draw(x - (width / 2) + radius, y - (height / 2) + radius) --左上
    obj.draw(x + (width / 2) - radius, y - (height / 2) + radius) --右上
    obj.draw(x - (width / 2) + radius, y + (height / 2) - radius) --左下
    obj.draw(x + (width / 2) - radius, y + (height / 2) - radius) --右下
end

obj.setoption("drawtarget", "tempbuffer", width, height)

if time == 0 then
    rounded_rect(0, 0, width, height * (35 / 108), 3, color)

    if red == 1 then
        rounded_rect(0, 0, width, height / 108, 3, 0xff0000)
    end
elseif time == 1 then
    --図形の高さが前と後で変わっててキレそう
    rounded_rect(0, -height * (61 / 216), width, height * (13 / 54), 3, color)
    rounded_rect(0, height * (61 / 216), width, height * (13 / 54), 3, color)
elseif time == 2 then
    rounded_rect(0, -height * (5 / 24), width, height / 54, 3, color)
    rounded_rect(0, height * (5 / 24), width, height / 54, 3, color)

    rounded_rect(0, height / 4 + 0.5, width, height * (7 / 108), 3, color)
    rounded_rect(0, -height / 4 - 0.5, width, height * (7 / 108), 3, color)

    rounded_rect(0, height / 2, width, height * (37 / 108), 3, color)
    rounded_rect(0, -height / 2, width, height * (37 / 108), 3, color)
elseif time == 3 then
    rounded_rect(0, height * (17 / 72), width, height / 54, 3, color)
    rounded_rect(0, -height * (17 / 72), width, height / 54, 3, color)

    rounded_rect(0, height / 3, width, height * (5 / 108), 3, color)
    rounded_rect(0, -height / 3, width, height * (5 / 108), 3, color)

    rounded_rect(0, height / 2, width, height * (17 / 108), 3, color)
    rounded_rect(0, -height / 2, width, height * (17 / 108), 3, color)
end
obj.setoption("drawtarget", "framebuffer")
obj.load("tempbuffer")

@...パルス
--track0:サイズ,0,1000,40,1
--track1:縦横比,-100,100,0,1
--track2:シード,-1000,1000,0,1
--dialog:色1/col,color1=0x006bff;色2/col,color2=0x00fbff;色3/col,color3=0x91fffc;色4/col,color4=0x1cd9ff;図形/fig,f="円";

local size = obj.track0
local aspect = obj.track1
local seed = obj.track2

-- 本家のサイズを40、60fpsとして考える
local size_rate = size / 40
local fps_rate = obj.framerate / 60

-- 1層目
obj.setoption("drawtarget", "tempbuffer", size * 2.75 + 63 * size_rate, size * 2.75 + 63 * size_rate)
obj.load("figure", f, color1, size * 2.75)
obj.aspect = aspect / 100
obj.effect("ぼかし", "範囲", 63 * size_rate)
obj.effect("ノイズ", "強さ", 52, "変化速度", 52 * fps_rate, "周期X", 0.72 / size_rate, "周期Y", 0.72 / size_rate, "seed", seed)
obj.draw()

-- 2層目
obj.load("figure", f, color2, size * 1.375)
obj.aspect = aspect / 100
obj.effect("グロー", "強さ", 26, "拡散", 37, "ぼかし", 0)
obj.effect("ぼかし", "範囲", 18 * size_rate)
obj.effect("ノイズ", "変化速度", 33 * fps_rate, "周期X", 0.2 / size_rate, "周期Y", 0.2 / size_rate, "しきい値", 45, "seed", seed)
obj.draw()

-- 3層目
obj.load("figure", f, color3, size, 4 * size_rate)
obj.aspect = aspect / 100
obj.effect("ラスター", "横幅", 7 * size_rate, "高さ", 15 * size_rate, "縦ラスター", 0, "ランダム振幅", 1)
obj.effect("ラスター", "横幅", 7 * size_rate, "高さ", 15 * size_rate, "縦ラスター", 1, "ランダム振幅", 1)
obj.effect("グロー", "強さ", 34, "拡散", 42, "しきい値", 40, "color", color4, "ぼかし", 1, "no_color", 0)
obj.draw()

obj.setoption("drawtarget", "framebuffer")
obj.load("tempbuffer")

@表裏リトマス
--track0:Xサイズ,0,1080,48,0.1
--track1:Yサイズ,0,1080,240,0.1
--track2:時間,1,60,1,0.1
--dialog:拡散,kak=70;ライン幅,l=1;色/col,color=0x00ffff;

local width = obj.track0
local height = obj.track1
local time = obj.track2
time = time - 1

-- サイズから縦横比を計算
local aspect = -1 + (height / width)
local size = width
if width < height then
    size = height
    aspect = 1 - (width / height)
end

-- 1層目
obj.load("figure", "四角形", color, size, 4000, aspect)
obj.effect("拡散光", "強さ", 100, "拡散", kak + (500 - kak) * (time / 60))
obj.alpha = 1 - (time / 60)
obj.draw()

-- 2層目
obj.load("figure", "四角形", 0xffffff, size + 1, 1, aspect)
obj.alpha = 1 - (time / 60)
obj.effect("グロー", "拡散", kak * 1.14583 - (kak * 1.14583 * (time / 60)))
obj.draw()

@アブジェ波紋
--track0:半径,0,5000,100,1
--track1:ライン幅,0,100,10,1
--track2:ラスター幅, 0, 100, 50, 1
--dialog:色1/col,col1=0x3535ce;色2/col,col2=0x6363ff;色3/col,col3=0x9e9eff;図形/fig,figure="円";シード/seed,seed=0;

local radius = obj.track0
local line = obj.track1
local raster = obj.track2
local raster2 = raster * 0.8

if radius < line * 10 + 30 then
    local x = radius / (line * 10 + 30)
    raster2 = raster2 * x
end
--一層目(ぼかした円)
obj.load("figure", figure, col1, radius + line * 9, line * 8)
obj.effect("ラスター", "横幅", raster, "高さ", 80, "周期", 1, "ランダム振幅", 1)
obj.effect("ラスター", "横幅", raster, "高さ", 80, "周期", 1, "縦ラスター", 1, "ランダム振幅", 1)
obj.effect("ノイズ", "強さ", 10, "速度Y", 0, "変化速度", 4, "周期X", 1, "周期Y", 1, "しきい値", 0, "シード", seed)
obj.effect("ぼかし", "範囲", 100)
obj.draw()

--2層目(水色)
obj.load("figure", figure, col2, radius + (line * 0.6), line * 1.2)
obj.effect("ラスター", "横幅", raster2, "高さ", 200, "周期", 2, "ランダム振幅", 1)
obj.effect("ラスター", "横幅", raster2, "高さ", 200, "周期", 2, "縦ラスター", 1, "ランダム振幅", 1)
obj.effect("ラスター", "横幅", raster2 * 0.4, "高さ", 50, "周期", 6, "ランダム振幅", 1)
obj.effect("ラスター", "横幅", raster2 * 0.4, "高さ", 50, "周期", 6, "縦ラスター", 1, "ランダム振幅", 1)
obj.effect("ノイズ", "強さ", 100, "速度Y", -1.5, "変化速度", 2.1, "周期X", 2, "周期Y", 3.13, "シード", seed)
obj.effect("グロー", "強さ", 60, "拡散", 30, "しきい値", 5, "ぼかし", 10, "color", col2, "no_color", 0)
obj.draw()

--3層目(白い光)
obj.load("figure", figure, 0xffffff, radius + (line / 2), line)
obj.effect("ぼかし", "範囲", 5)
obj.draw()

@K2雨
--track0: 量,0,20000,150,1
--track1:速さ,0,20000,4000,0.001
--track2:風,-10000,10000,0,0.1
--track3:速さの感度,0,1,1,0.01
--dialog:大きさ,drop_size=3.00;風バリエーション,windvar=0.0;奥行き,depth=5000;拡散,spread=6.00;長さ,length=100;色/col,color=0xffffff;不透明度,alpha=25.0;シード,seed=0;風の感度,driver_wind_sensitive=1;画面横幅,buffer_w=1920;画面縦幅,buffer_h=1080;ドライバーをリセット/chk,reset=0;

local drops = obj.track0
local speed = obj.track1
local wind = obj.track2
local driver_speed_sensitive = obj.track3
local MIN_Y_RATE = 0.8
local MAX_Y_RATE = 1.2
math.randomseed(seed + obj.frame * 132)

function undef_array_check(global_array)
    return #global_array
end

function undef_number_check(global_number)
    return global_number+1
end

-- ドライバーをリセット
if reset == 1 then
    k2_driver_speed = nil
    k2_driver_wind = nil
end

-- ドライバーがあれば更新
if pcall(undef_number_check, k2_driver_speed) and pcall(undef_number_check, k2_driver_wind) then
    speed = speed * (1 - driver_speed_sensitive) + k2_driver_speed * driver_speed_sensitive
    wind = wind * (1 - driver_wind_sensitive) + k2_driver_wind * driver_wind_sensitive
end

function random_float(min, max)
    if max - min <= 1 then
        return min + math.random() * (max - min)
    else 
        return math.random(min, max - 1) + math.random()
    end
end

-- テーブルを初期化
-- https://scrapbox.io/totti95u/AviUtlでフレームで初期化されない変数が欲しい
function init_drops()
    local result = {}
    for i = 1, drops do
        local x = random_float(-buffer_w / 2, buffer_w / 2)
        local y = random_float(-buffer_h / 2, buffer_h / 2)
        local z = math.random(0, depth)
        local x_rate = random_float(-spread / 90, spread / 90)
        local y_rate = random_float(MIN_Y_RATE, MAX_Y_RATE)
        local wind_rate = 1 + random_float(-windvar, windvar) / 100
        table.insert(result, {x = x, y = y, z = z, x_rate = x_rate, y_rate = y_rate, wind_rate = wind_rate})
    end
    return result
end

if not(pcall(undef_array_check, global_drops)) or (obj.frame == 0) then
    global_drops = {}
end

local do_init_drops = not(pcall(undef_array_check, global_drops[obj.layer]))
if do_init_drops then
    global_drops[obj.layer] = init_drops()
end
local drops_table = global_drops[obj.layer]

--画面外の雨粒の削除
local i = 1
while i <= #drops_table do
    local delete = false
    if (drops_table[i].x < -buffer_w / 2) and (wind < 0) then
        delete = true
    end
    if (drops_table[i].x > buffer_w / 2) and (wind > 0) then
        delete = true
    end
    if drops_table[i].y > buffer_h / 2 + speed / obj.framerate * (length / 100) then
        delete = true
    end

    if delete then
        table.remove(drops_table, i)
    else
        i = i + 1
    end
end

-- 雨粒の移動
function drop_move(drop)
    drop.x = drop.x + speed / obj.framerate * drop.x_rate + wind / obj.framerate * drop.wind_rate
    drop.y = drop.y + speed / obj.framerate * drop.y_rate
    return drop
end
for i = 1, #drops_table do
    drops_table[i] = drop_move(drops_table[i])
end

-- 雨粒の生成
local current_drops = #drops_table
local spawning_drops = drops - current_drops

function spawn_drops(side)
    local x, y
    if side == 0 then
        x = math.random(-buffer_w / 2, buffer_w / 2)
        y = -buffer_h / 2 + random_float(0, speed / obj.framerate)
    elseif side == 1 then
        x = -buffer_w / 2 - random_float(wind / obj.framerate, 0)
        y = math.random(-buffer_h / 2, buffer_h / 2)
    else
        x = buffer_w / 2 + random_float(0, wind / obj.framerate)
        y = math.random(-buffer_h / 2, buffer_h / 2)
    end
    local z = math.random(0, depth)
    local x_rate = random_float(-spread / 90, spread / 90)
    local y_rate = random_float(MIN_Y_RATE, MAX_Y_RATE)
    local wind_rate = 1 + random_float(-windvar, windvar) / 100
    return {x = x, y = y, z = z, x_rate = x_rate, y_rate = y_rate, wind_rate = wind_rate}
end

if not do_init_drops then
    local side_probability = math.abs(math.atan2(wind,speed) / math.pi * 2)
    for i = 1, spawning_drops do
        local side = 0
        if math.random() > side_probability then
            side = 0
        else
            if wind > 0 then
                side = 1
            elseif wind < 0 then
                side = 2
            else
                side = math.random(1, 2)
            end
        end
        table.insert(drops_table, spawn_drops(side))
    end
end

-- 雨粒を仮想バッファに描画
obj.setoption("drawtarget", "tempbuffer", buffer_w, buffer_h)
for i, drop in ipairs(drops_table) do
    local start_x = drop.x - speed / obj.framerate * drop.x_rate * length / 100- wind / obj.framerate * drop.wind_rate
    local start_y = drop.y - speed / obj.framerate * drop.y_rate * length / 100
    local center_x = (drop.x + start_x) / 2
    local center_y = (drop.y + start_y) / 2
    local drop_length = math.sqrt(math.abs(drop.x - start_x) ^ 2 + math.abs(drop.y - start_y) ^ 2)
    if drop_length < drop_size then
        drop_length = drop_size
    end
    obj.load("figure", "四角形", color, 100)
    obj.effect("リサイズ", "X", drop_size, "Y", drop_length, "ドット数でサイズ指定", 1)
    obj.draw(center_x, center_y, drop.z, 1, alpha / 100, 0, 0, math.deg(-math.atan2(drop.x - start_x, drop.y - start_y)))
end

obj.setoption("drawtarget", "framebuffer")
obj.load("tempbuffer")
global_drops[obj.layer] = drops_table

-- for i, drop in ipairs(drops_table) do
--     print("x: " .. drop.x .. "\ny: " .. drop.y .. "\nz: " .. drop.z .. "\nxr: " .. drop.x_rate .. "\nyr: " .. drop.y_rate .. "\nwr: " .. drop.wind_rate)
-- end

@K2雨ドライバー
--track0:速さ,0,20000,4000,0.001
--track1:風,-10000,10000,0,0.1

function undef_number_check(global_number)
    return global_number+1
end
k2_driver_speed = obj.track0
k2_driver_wind = obj.track1
